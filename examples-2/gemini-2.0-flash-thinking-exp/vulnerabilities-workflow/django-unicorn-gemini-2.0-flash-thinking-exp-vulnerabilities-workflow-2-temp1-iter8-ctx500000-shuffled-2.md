- Vulnerability Name: Cross-Site Scripting (XSS) in Template Rendering
- Description:
    - An attacker can inject malicious JavaScript code into a component property, such as `name` in the `HelloWorldView` example.
    - When the Django template renders the component, it directly outputs the value of the `name` property into the HTML using `{{ name|title }}`.
    - If the attacker provides a malicious string containing JavaScript (e.g., `<script>alert("XSS")</script>`), this script will be executed in the user's browser when the component is rendered.
    - This vulnerability is due to the lack of automatic output escaping in Django templates when rendering component properties and the `django-unicorn` library not enforcing or providing clear, secure defaults for handling user-provided content.
- Impact:
    - Successful XSS attacks can lead to various malicious activities:
        - Account hijacking: Stealing session cookies or other authentication tokens.
        - Data theft: Accessing sensitive user data or application data.
        - Website defacement: Modifying the content of the web page seen by the user.
        - Redirection to malicious sites: Redirecting users to phishing or malware distribution websites.
        - Execution of arbitrary JavaScript code: Performing actions on behalf of the user, like making API calls or modifying data.
- Vulnerability Rank: High
- Currently Implemented Mitigations:
    - CSRF protection: Django's CSRF protection is mentioned as a security measure to prevent "nefarious AJAX POSTs". However, CSRF protection does not prevent XSS vulnerabilities; it prevents Cross-Site Request Forgery attacks.
    - Component checksum: A component checksum is mentioned to ensure that "all updates are valid". This mechanism seems to prevent tampering with the component's internal state during AJAX requests, but it does not prevent XSS in template rendering.
    - HTML encoding: Changelog v0.36.0 mentions a security fix (CVE-2021-42053) to prevent XSS attacks, stating that "responses will be HTML encoded going forward". However, it also mentions an opt-out using the `safe` filter, and the vulnerability persists if `safe` filter or `Meta.safe` option is used incorrectly, or if automatic escaping is not comprehensive enough.
- Missing Mitigations:
    - Automatic and comprehensive output escaping: The library should automatically escape all rendered component properties by default to prevent XSS. Developers should be guided towards secure defaults rather than needing to manually apply escaping.
    - Clear documentation and warnings: The documentation should prominently warn about the risks of XSS and clearly explain how to properly sanitize user inputs when rendering component properties, especially when using `safe` filter or `Meta.safe`. It should emphasize that `safe` should only be used when explicitly intended and after careful sanitization.
    - Security focused examples and templates: Examples should showcase secure coding practices, including proper output escaping. Templates generated by `startunicorn` management command should also encourage secure practices.
    - Security testing and code analysis:  More thorough security testing and code analysis should be implemented to identify and mitigate potential XSS vulnerabilities across the library.
- Preconditions:
    - A Django Unicorn component is used to render user-controlled data in a template.
    - The developer does not manually sanitize the user-controlled data in the template and either uses `safe` filter incorrectly or relies on potentially insufficient automatic escaping if it exists.
- Source Code Analysis:
    - Based on the documentation, especially `docs\source\templates.md`, the template engine directly renders component properties.
    - `unicorn:model` binds user input to component properties.
    - The example in `docs\source\components.md` for `hello-world.html` directly renders `{{ name|title }}` without explicit sanitization, demonstrating the vulnerability.
    - The documentation for `Meta.safe` in `docs\source\views.md` suggests that fields in `Meta.safe` are *not* HTML encoded, highlighting a potential bypass for any automatic escaping and a clear XSS risk if used improperly.
    - The changelog v0.36.0 indicates a previous XSS vulnerability (CVE-2021-42053) and a fix with HTML encoding, but the existence of `Meta.safe` and the need for explicit sanitization are strong indicators that vulnerabilities can still be present if developers are not careful.
- Security Test Case:
    1.  Create a Django Unicorn component (e.g., `xss_test_component`) with a property `user_input`.
    2.  In the component's template (`xss_test_component.html`), render the `user_input` property directly: `<div>{{ user_input }}</div>`.
    3.  Create a Django view and template that includes the `xss_test_component`.
    4.  Access the page in a browser.
    5.  Use browser developer tools to inspect the input element associated with `user_input` (if any) or directly manipulate the component's data sent in AJAX requests (if you can intercept them or construct your own).
    6.  Inject a malicious XSS payload as the value for `user_input`, for example: `<script>alert('XSS Vulnerability')</script>`. This could be done by:
        - If there's an input field bound to `user_input` with `unicorn:model`, type the payload into the input.
        - If not, or to bypass potential client-side filtering, craft a POST request to the Unicorn endpoint for this component. The request should mimic a legitimate request but include the malicious payload in the `data` section for `user_input`. You'll need to figure out the component ID, name, and a valid checksum (you can get these from the initial page load).
    7.  Submit the request or trigger an update to the component (e.g., by blurring the input field if using `unicorn:model`).
    8.  Observe if the JavaScript alert (`alert('XSS Vulnerability')`) executes in the browser. If it does, the XSS vulnerability is confirmed.
