### Vulnerability List

- Vulnerability Name: Potential Cross-Site Scripting (XSS) through `safe` Meta Option
- Description: Django-unicorn allows developers to mark component fields as `safe` via the `Meta` class. This `safe` option is intended for developers to explicitly bypass the default HTML encoding for specific component fields. However, if a developer mistakenly or without sufficient understanding marks a field that renders user-controlled data as `safe` and then includes this field in a Django template without proper sanitization, it can lead to a Cross-Site Scripting (XSS) vulnerability. In such a scenario, an attacker can inject malicious JavaScript code into the user input. When the component is rendered by django-unicorn, this malicious code will be executed in the victim's browser because the `safe` option prevents the library from automatically HTML encoding the user-provided input.
- Impact: A successful XSS attack can have severe consequences. It can enable attackers to hijack user sessions, steal cookies, redirect users to malicious websites, and deface web pages. In critical scenarios, it can lead to complete compromise of user accounts and sensitive data, undermining the integrity and trustworthiness of the web application.
- Vulnerability Rank: High
- Currently Implemented Mitigations: Django-unicorn, by default, implements HTML encoding for updated field values. This is a crucial built-in mitigation to prevent XSS attacks in most common use cases. The documentation at `docs\source\views.md` under the `Meta` section explicitly mentions this default behavior, stating: "By default, `unicorn` HTML encodes updated field values to prevent XSS attacks." The `safe` option is presented as an explicit opt-in to disable this encoding for specific fields when developers require unencoded HTML output.  Furthermore, the library provides a utility function `sanitize_html` in `django_unicorn\utils.py` which can be used to escape HTML special characters.
- Missing Mitigations: The primary missing mitigation is the lack of prominent and explicit warnings in the official documentation regarding the security implications of using the `safe` option with user-controlled data. While the documentation describes the `safe` option, it does not adequately emphasize the risk of introducing XSS vulnerabilities if developers fail to sanitize user inputs when using `safe`.  Specifically, there is no guidance or best practices provided on how to properly sanitize user-controlled data when the `safe` option is used. This absence of clear security guidance increases the risk of developers unknowingly creating XSS vulnerabilities by misusing the `safe` option. Although `sanitize_html` utility function exists, it is not enforced or suggested to be used with `safe` option in documentation.
- Preconditions:
    - A Django-unicorn component is implemented and used within the Django application that renders data originating from user input.
    - The developer, intending to allow raw HTML or due to misunderstanding the security implications, configures the component's `Meta` class to mark the field that displays user-controlled data as `safe`.
    - An attacker can manipulate user input and inject malicious JavaScript payloads into the data that is bound to the `safe` field in the component.
- Source Code Analysis:
    - Documentation analysis from `docs\source\views.md` -> `Meta` -> `safe`: As previously noted, the documentation confirms the default HTML encoding and that `safe` is an opt-in to bypass this.
    - Code Review: Examination of the provided project files, specifically within `django_unicorn\views\action_parsers\sync_input.py` and `django_unicorn\views\action_parsers\utils.py`, reveals the mechanism for updating component properties based on user input. The `set_property_value` function is responsible for setting new values to component properties. While this function handles property updates, it does not include any HTML sanitization logic when `safe` option is enabled. The sanitization is intentionally skipped when the `safe` meta option is enabled for a field. This design decision places the burden of sanitization entirely on the developer when they choose to use the `safe` option.  The file `django_unicorn\utils.py` includes `sanitize_html` function, demonstrating the library's awareness of HTML sanitization, but this function is not automatically applied or suggested for use with the `safe` option. Further analysis of `django_unicorn\views\__init__.py` confirms the overall request processing flow and action handling, reinforcing the context of how user input reaches the component properties. The file `django_unicorn\tests\views\message\test_sync_input.py` demonstrates the functionality of `syncInput` action, which is the primary mechanism for updating component properties based on user interactions, and thus, relevant to understanding how unsanitized user input can be passed to `safe` fields. The test file `django_unicorn\tests\views\test_process_component_request.py` contains `test_safe_html_entities_not_encoded` test which explicitly verifies that when `safe` option is enabled, HTML entities are not encoded, confirming the intended behavior and the potential for XSS if unsanitized user input is used.
    - Visualization:
        ```
        User Input (Malicious JavaScript) --> HTTP Request --> Django-unicorn (syncInput action) --> set_property_value (NO SANITIZATION for 'safe' fields) --> Component.field (marked as safe) --> Django Template Rendering (unescaped output) --> Browser (JavaScript execution) --> XSS Vulnerability
        ```
- Security Test Case:
    1. Setup: Initialize a new Django project and install the django-unicorn library.
    2. Component Creation: Create a new django-unicorn component named `safe_xss_component`.
    3. Component View Implementation (`components/safe_xss_component.py`): Define a component view class `SafeXssView` with a field named `unsafe_input` initialized as an empty string. Add a `Meta` class within `SafeXssView` and declare `safe = ("unsafe_input", )` to mark the `unsafe_input` field as safe.
    4. Template Design (`templates/unicorn/safe_xss_component.html`): Create the component's HTML template. Include an input field that is bound to the `unsafe_input` property using `unicorn:model="unsafe_input"`. Render the `unsafe_input` value within a `div` element with id `xss_output`:
       ```html
       <div>
           <input type="text" unicorn:model="unsafe_input">
           <div id="xss_output">{{ unsafe_input }}</div>
       </div>
       ```
    5. Django View and Template Integration: Create a Django view (e.g., in `views.py`) and a corresponding Django template to render and display the `safe_xss_component`. Ensure the django-unicorn template tags are loaded in the Django template (`{% load unicorn %}`).
    6. Access the Application: Run the Django development server and access the Django view in a web browser.
    7. Inject XSS Payload: In the input field of the `safe_xss_component`, enter a standard JavaScript XSS payload, for example: `<img src=x onerror=alert('XSS Vulnerability')>`.
    8. Observe XSS Execution: Observe the immediate execution of the JavaScript payload. A JavaScript alert box displaying "XSS Vulnerability" will appear in the browser. This confirms the XSS vulnerability because the input provided was rendered without HTML encoding due to the `safe` meta option, and the injected JavaScript was executed by the browser.
