### Vulnerability List

- Vulnerability Name: Arbitrary Code Execution via `LaravelExtraIntellisense.phpCommand` setting

- Description:
    1. An attacker crafts a malicious `phpCommand` string. This string can contain arbitrary PHP code or system commands.
    2. The attacker uses social engineering to trick a developer into setting `LaravelExtraIntellisense.phpCommand` in their VSCode settings to the malicious string. This could be done through phishing, forum posts, or other communication channels, by suggesting it as a "configuration tip" for a specific use case (e.g., Docker, different PHP versions, etc.).
    3. Once the developer sets the malicious `phpCommand`, the extension, during its normal operation of providing autocompletion, will use this command to execute PHP code.
    4. The extension uses `LaravelExtraIntellisense.phpCommand` to execute PHP scripts to gather information about the Laravel project (routes, views, configs, etc.). The `{code}` placeholder in the command is replaced with PHP code generated by the extension.
    5. However, if the base command itself is malicious, the attacker's code will be executed on the developer's machine with the privileges of the VSCode process.

- Impact:
    - **Critical**. Arbitrary code execution on the developer's machine.
    - An attacker can gain full control over the developer's workstation.
    - Potential data theft, installation of malware, or further attacks on internal networks accessible from the developer's machine.

- Vulnerability Rank: Critical

- Currently Implemented Mitigations:
    - **Security Note in README.md**: The README.md file contains a "Security Note" that warns users about the extension running their Laravel application and to be cautious about the `phpCommand` setting.
        ```markdown
        ## Security Note
        This extension runs your Laravel application automatically and periodically to get the information needed to provide autocomplete.

        So if you have any unknown errors in your log make sure the extension not causing it.

        Also if you writing any sensitive code in your service providers, disable the extension temporarily to prevent unwanted application executing.
        ```
        This is a documentation-based mitigation, warning the user but not preventing the vulnerability.

- Missing Mitigations:
    - **Input Validation and Sanitization**: The extension should validate and sanitize the `LaravelExtraIntellisense.phpCommand` setting to prevent execution of arbitrary commands. At a minimum, it should:
        - Check if the command starts with "php".
        - Restrict the command to only execute PHP and prevent shell command injection.
        - Ideally, disallow any user-provided command execution and use a safer mechanism to interact with Laravel (if possible).
    - **Principle of Least Privilege**: The extension should ideally not require arbitrary command execution to function. Explore alternative approaches to gather autocompletion data that do not involve executing user-defined commands.
    - **User Consent**:  Before using the `phpCommand` setting for the first time, the extension could display a warning message explaining the security implications and ask for explicit user consent.

- Preconditions:
    - The developer must have the Laravel Extra Intellisense extension installed in VSCode.
    - The developer must be tricked into setting a malicious `LaravelExtraIntellisense.phpCommand` in their VSCode settings.
    - The developer must be working on a Laravel project in VSCode with the extension active.

- Source Code Analysis:
    1. **`helpers.ts` - `runPhp` function**:
        ```typescript
        static async runPhp(code: string, description: string|null = null) : Promise<string> {
            code = code.replace(/\"/g, "\\\"");
            if (['linux', 'openbsd', 'sunos', 'darwin'].some(unixPlatforms => os.platform().includes(unixPlatforms))) {
                code = code.replace(/\$/g, "\\$");
                code = code.replace(/\\\\'/g, '\\\\\\\\\'');
                code = code.replace(/\\\\"/g, '\\\\\\\\\"');
            }
            let commandTemplate = vscode.workspace.getConfiguration("LaravelExtraIntellisense").get<string>('phpCommand') ?? "php -r \"{code}\"";
            let command = commandTemplate.replace("{code}", code);
            let out = new Promise<string>(function (resolve, error) {
                if (description != null) {
                    Helpers.outputChannel?.info("Laravel Extra Intellisense command started: " + description);
                }

                cp.exec(command,
                    { cwd: vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0 ? vscode.workspace.workspaceFolders[0].uri.fsPath : undefined },
                    function (err, stdout, stderr) {
                        if (err == null) {
                            if (description != null) {
                                Helpers.outputChannel?.info("Laravel Extra Intellisense Resolved: " + description);
                            }
                            resolve(stdout);
                        } else {
                            const errorOutput = stderr.length > 0 ? stderr : stdout;
                            Helpers.outputChannel?.error("Laravel Extra Intellisense Error:\n " + (description ?? '') + '\n\n' + errorOutput);
                            Helpers.showErrorPopup();
                            error(errorOutput);
                        }
                    }
                );
            });
            return out;
        }
        ```
        - This function retrieves the `phpCommand` from VSCode configuration.
        - It uses `cp.exec(command, ...)` to execute the command, which can be any arbitrary command if the `phpCommand` setting is malicious.
        - Minimal escaping is performed on the `code` being injected, but **no validation or sanitization is done on the `commandTemplate` itself (the user-provided `phpCommand`)**.
        - The `phpCommand` setting is directly used in `cp.exec`, making it vulnerable to command injection if a user sets a malicious command.

    2. **`helpers.ts` - `runLaravel` function**:
        ```typescript
        static runLaravel(code: string, description: string|null = null) : Promise<string> {
            code = code.replace(/(?:\r\n|\r|\n)/g, ' ');
            if (fs.existsSync(Helpers.projectPath("vendor/autoload.php")) && fs.existsSync(Helpers.projectPath("bootstrap/app.php"))) {
                var command =
                    "define('LARAVEL_START', microtime(true));" +
                    "require_once '" + Helpers.projectPath("vendor/autoload.php", true) + "';" +
                    "$app = require_once '" + Helpers.projectPath("bootstrap/app.php", true) + "';" +
                    "class VscodeLaravelExtraIntellisenseProvider extends \\Illuminate\\Support\\ServiceProvider" +
                    "{" +
                    "   public function register() {}" +
                    "	public function boot()" +
                    "	{" +
                    "       if (method_exists($this->app['log'], 'setHandlers')) {" +
                    "			$this->app['log']->setHandlers([new \\Monolog\\Handler\\ProcessHandler()]);" +
                    "		}" +
                    "	}" +
                    "}" +
                    "$app->register(new VscodeLaravelExtraIntellisenseProvider($app));" +
                    "$kernel = $app->make(Illuminate\\Contracts\\Console\\Kernel::class);" +

                    "$status = $kernel->handle(" +
                        "$input = new Symfony\\Component\\Console\\Input\\ArgvInput," +
                        "new Symfony\\Component\\Console\\Output\\ConsoleOutput" +
                    ");" +
                    "if ($status == 0) {" +
                    "	echo '___VSCODE_LARAVEL_EXTRA_INSTELLISENSE_OUTPUT___';" +
                        code +
                    "	echo '___VSCODE_LARAVEL_EXTRA_INSTELLISENSE_END_OUTPUT___';" +
                    "}" +
                    "$kernel->terminate($input, $status);" +
                    "exit($status);"

                var self = this;

                return new Promise(function (resolve, error) {
                    self.runPhp(command, description)
                        .then(function (result: string) {
                            var out : string | null | RegExpExecArray = result;
                            out = /___VSCODE_LARAVEL_EXTRA_INSTELLISENSE_OUTPUT___(.*)___VSCODE_LARAVEL_EXTRA_INSTELLISENSE_END_OUTPUT___/g.exec(out);
                            if (out) {
                                resolve(out[1]);
                            } else {
                                error("PARSE ERROR: " + result);

                                Helpers.outputChannel?.error("Laravel Extra Intellisense Parse Error:\n " + (description ?? '') + '\n\n' + result);
                                Helpers.showErrorPopup();
                            }
                        })
                        .catch(function (e : Error) {
                            error(e);
                        });
                });
            }
            return new Promise((resolve, error) => resolve(""));
        }
        ```
        - This function constructs a PHP script to bootstrap Laravel and execute the provided `code`.
        - It then calls `runPhp` to execute this entire script using the user-defined `phpCommand`.
        - The vulnerability lies in the fact that `runLaravel` relies on `runPhp`, which is vulnerable due to the insecure usage of `LaravelExtraIntellisense.phpCommand`.

- Security Test Case:
    1. **Prerequisites**:
        - Install the Laravel Extra Intellisense extension in VSCode.
        - Open a Laravel project in VSCode.
    2. **Modify VSCode Settings**:
        - Open VSCode settings (File -> Preferences -> Settings or Code -> Settings -> Settings).
        - Go to Extension Settings for "Laravel Extra Intellisense".
        - Find the `LaravelExtraIntellisense: Php Command` setting.
        - **Set the `LaravelExtraIntellisense: Php Command` to the following malicious command:**
          ```
          bash -c "touch /tmp/pwned"
          ```
          or for Windows:
          ```
          powershell -c "New-Item -ItemType File -Path C:\Windows\Temp\pwned.txt"
          ```
        - This command will attempt to create a file named `pwned` in the `/tmp` directory (Linux/macOS) or `pwned.txt` in `C:\Windows\Temp\` (Windows) when the extension executes it.
    3. **Trigger Extension Activity**:
        - Open any PHP or Blade file in the Laravel project editor.
        - Type `route(` or `config(` or any other function that triggers the extension's autocompletion features. This will force the extension to execute PHP code using the malicious `phpCommand`.
    4. **Verify Exploitation**:
        - **Linux/macOS**: Open a terminal and check if the file `/tmp/pwned` exists using `ls /tmp/pwned`. If it exists, the vulnerability is confirmed.
        - **Windows**: Open PowerShell or Command Prompt and check if the file `C:\Windows\Temp\pwned.txt` exists. If it exists, the vulnerability is confirmed.
    5. **Expected Result**:
        - The file `/tmp/pwned` or `C:\Windows\Temp\pwned.txt` should be created, demonstrating that arbitrary code execution was achieved by setting a malicious `LaravelExtraIntellisense.phpCommand`.
