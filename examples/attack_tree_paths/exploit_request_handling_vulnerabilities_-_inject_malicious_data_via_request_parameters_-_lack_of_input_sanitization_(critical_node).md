```python
from flask import Flask, request, render_template_string
import sqlite3
import subprocess
import html

app = Flask(__name__)

# Example of a vulnerable route susceptible to SQL Injection
@app.route('/search_user')
def search_user():
    username = request.args.get('username')
    if username:
        conn = sqlite3.connect('users.db')
        cursor = conn.cursor()
        # Vulnerable code: Directly embedding user input in SQL query
        query = f"SELECT * FROM users WHERE username = '{username}'"
        try:
            cursor.execute(query)
            results = cursor.fetchall()
            conn.close()
            return render_template_string("<h2>Search Results for {{ username }}:</h2><ul>{% for row in results %}<li>{{ row }}</li>{% endfor %}</ul>", username=username, results=results)
        except sqlite3.Error as e:
            conn.close()
            return f"Database Error: {e}"
    return '''
        <form action="/search_user" method="get">
            <label for="username">Enter Username:</label>
            <input type="text" id="username" name="username">
            <input type="submit" value="Search">
        </form>
    '''

# Example of a vulnerable route susceptible to XSS
@app.route('/display_message')
def display_message():
    message = request.args.get('message')
    # Vulnerable code: Directly displaying user input in HTML
    return render_template_string("<h2>You entered: {{ message }}</h2>", message=message)

# Example of a vulnerable route susceptible to Command Injection
@app.route('/run_command')
def run_command():
    command = request.args.get('command')
    if command:
        try:
            # Vulnerable code: Directly using user input in system command
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            return f"<pre>Command: {command}\nStdout:\n{result.stdout}\nStderr:\n{result.stderr}</pre>"
        except Exception as e:
            return f"Error executing command: {e}"
    return '''
        <form action="/run_command" method="get">
            <label for="command">Enter Command:</label>
            <input type="text" id="command" name="command">
            <input type="submit" value="Run">
        </form>
    '''

# Example of a route with input sanitization to prevent SQL Injection
@app.route('/safe_search_user')
def safe_search_user():
    username = request.args.get('username')
    if username:
        conn = sqlite3.connect('users.db')
        cursor = conn.cursor()
        # Safe code: Using parameterized query to prevent SQL Injection
        query = "SELECT * FROM users WHERE username = ?"
        try:
            cursor.execute(query, (username,))
            results = cursor.fetchall()
            conn.close()
            return render_template_string("<h2>Search Results for {{ username }}:</h2><ul>{% for row in results %}<li>{{ row }}</li>{% endfor %}</ul>", username=username, results=results)
        except sqlite3.Error as e:
            conn.close()
            return f"Database Error: {e}"
    return '''
        <form action="/safe_search_user" method="get">
            <label for="username">Enter Username:</label>
            <input type="text" id="username" name="username">
            <input type="submit" value="Search">
        </form>
    '''

# Example of a route with input sanitization to prevent XSS
@app.route('/safe_display_message')
def safe_display_message():
    message = request.args.get('message')
    # Safe code: Using Jinja2's automatic escaping to prevent XSS
    return render_template_string("<h2>You entered: {{ message }}</h2>", message=message)

# Example of a route with input sanitization to prevent Command Injection
@app.route('/safe_run_command')
def safe_run_command():
    command = request.args.get('command')
    if command:
        # Basic sanitization: Whitelisting allowed commands (highly recommended)
        allowed_commands = ['ping', 'traceroute']
        if command.split(' ')[0] in allowed_commands:
            try:
                # Still be cautious even with whitelisting, consider further input validation
                result = subprocess.run(command, shell=False, capture_output=True, text=True)
                return f"<pre>Command: {command}\nStdout:\n{result.stdout}\nStderr:\n{result.stderr}</pre>"
            except Exception as e:
                return f"Error executing command: {e}"
        else:
            return "Invalid command."
    return '''
        <form action="/safe_run_command" method="get">
            <label for="command">Enter Command:</label>
            <input type="text" id="command" name="command">
            <input type="submit" value="Run">
        </form>
    '''

if __name__ == '__main__':
    # Create a dummy database for SQL injection examples
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute("DROP TABLE IF EXISTS users")
    cursor.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT)")
    cursor.execute("INSERT INTO users (username) VALUES ('alice')")
    cursor.execute("INSERT INTO users (username) VALUES ('bob')")
    conn.commit()
    conn.close()
    app.run(debug=True)
```
